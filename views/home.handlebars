<h1 class="page-title">{{title}}</h1>

<section class="intro-section">
  <p>
  <i>Välkommen till Ontology Browser, ett verktyg för att utforska och ladda ner ontologier från GraphDB-databasen.</i>
</p>
  
  <div class="info-box">
    <h3>Vad är en ontologi?</h3>
    <p>
     <i> En ontologi är en formell representation av kunskap inom ett visst område som definierar begrepp, relationer och 
      egenskaper. Ontologier används för att organisera information, möjliggöra semantisk interoperabilitet och 
      stödja dataintegration genom att tillhandahålla ett gemensamt vokabulär. </i>
    </p>
    <p>
     <i> I denna databas finns olika ontologier som kan laddas ner i flera format som RDF/XML, Turtle, N-Triples och JSON-LD.</i>
    </p>
  </div>
</section>
<div class="info-box">
  <h3>Ontologi Navigator</h3>
  <p> <i>Utforska relaterade ontologier och hur de hänger ihop med varandra</i></p>
  
  <div class="ontology-explorer">
    <div class="explorer-search">
     <!-- <input type="text" id="ontologySearch" placeholder="Sök ontologi..." class="explorer-search-input"> -->
    </div>
    
    <div class="explorer-visualization">
      <div class="explorer-canvas" id="ontologyExplorerCanvas">
        <!-- Generated by JavaScript -->
      </div>
    </div>
    
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Get ontology data from the grid
        const ontologyCards = document.querySelectorAll('.ontology-card');
        const ontologies = [];
        
        ontologyCards.forEach((card, index) => {
          const titleElement = card.querySelector('.ontology-card-header h3 a');
          const descElement = card.querySelector('.ontology-card-body .description');
          const statsElements = card.querySelectorAll('.ontology-stats .stat');
          
          if (titleElement) {
            const uri = titleElement.getAttribute('href').split('uri=')[1].split('&')[0];
            
            ontologies.push({
              id: index,
              title: titleElement.textContent.trim(),
              uri: decodeURIComponent(uri),
              description: descElement ? descElement.textContent.trim() : '',
              classes: statsElements[0] ? parseInt(statsElements[0].textContent.split(':')[1].trim()) : 0,
              properties: statsElements[1] ? parseInt(statsElements[1].textContent.split(':')[1].trim()) : 0,
              x: 0,
              y: 0,
              connected: false // Track if this ontology is connected
            });
          }
        });
        
        // Only proceed if we have ontologies
        if (ontologies.length === 0) return;
        
        // Set up the explorer canvas
        const canvas = document.getElementById('ontologyExplorerCanvas');
        if (!canvas) return;
        
        const width = canvas.offsetWidth;
        const height = 400; // Fixed height
        canvas.style.height = height + 'px';
        
        // Position ontologies in a force-directed layout simulation
        // (Basic version for simplicity)
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) * 0.4;
        
        // Position in a circle first
        ontologies.forEach((ontology, index) => {
          const angle = (index / ontologies.length) * Math.PI * 2;
          ontology.x = centerX + radius * Math.cos(angle);
          ontology.y = centerY + radius * Math.sin(angle);
        });
        
        // Create connections between ontologies
        // We'll create connections based on some rules:
        // 1. Connect ontologies with similar titles
        // 2. Connect ontologies with similar class counts
        const connections = [];
        
        for (let i = 0; i < ontologies.length; i++) {
          for (let j = i + 1; j < ontologies.length; j++) {
            const ontologyA = ontologies[i];
            const ontologyB = ontologies[j];
            
            // Check title similarity (naive check for common words)
            const wordsA = ontologyA.title.toLowerCase().split(/\W+/).filter(w => w.length > 3);
            const wordsB = ontologyB.title.toLowerCase().split(/\W+/).filter(w => w.length > 3);
            const commonWords = wordsA.filter(word => wordsB.includes(word));
            
            // Check class count similarity
            const classDiff = Math.abs(ontologyA.classes - ontologyB.classes);
            const classRatio = Math.min(ontologyA.classes, ontologyB.classes) / Math.max(ontologyA.classes, ontologyB.classes) || 0;
            
            // Create connection if similar
            if (commonWords.length > 0 || classRatio > 0.7) {
              connections.push({
                source: i,
                target: j,
                strength: (commonWords.length * 0.2) + (classRatio * 0.8)
              });
              
              // Mark both ontologies as connected
              ontologyA.connected = true;
              ontologyB.connected = true;
            }
          }
        }
        
        // Ensure all ontologies are connected to at least one other ontology
        for (let i = 0; i < ontologies.length; i++) {
          if (!ontologies[i].connected) {
            // Find the closest ontology (by position in the circle)
            let closestIndex = (i + 1) % ontologies.length; // Default to next in circle
            
            // Look for an existing connected ontology if possible
            for (let j = 0; j < ontologies.length; j++) {
              if (i !== j && ontologies[j].connected) {
                closestIndex = j;
                break;
              }
            }
            
            // Create a connection to the closest ontology
            connections.push({
              source: i,
              target: closestIndex,
              strength: 0.5 // Medium strength for added connections
            });
            
            // Mark both ontologies as connected
            ontologies[i].connected = true;
            ontologies[closestIndex].connected = true;
          }
        }
        
        // Create a graph structure for more connections
        // Add more connections to create a more interconnected network
        // This ensures all ontologies are part of the same connected graph
        const minConnections = Math.min(3, ontologies.length - 1); // Each node should have at least this many connections
        
        for (let i = 0; i < ontologies.length; i++) {
          // Count existing connections for this ontology
          let connectionCount = 0;
          connections.forEach(conn => {
            if (conn.source === i || conn.target === i) {
              connectionCount++;
            }
          });
          
          // Add more connections if needed
          if (connectionCount < minConnections && ontologies.length > 3) {
            // Find ontologies that aren't already connected to this one
            const unconnectedIndices = [];
            for (let j = 0; j < ontologies.length; j++) {
              if (i !== j) {
                let alreadyConnected = false;
                connections.forEach(conn => {
                  if ((conn.source === i && conn.target === j) || 
                      (conn.source === j && conn.target === i)) {
                    alreadyConnected = true;
                  }
                });
                
                if (!alreadyConnected) {
                  unconnectedIndices.push(j);
                }
              }
            }
            
            // Add new connections until we reach the minimum
            while (connectionCount < minConnections && unconnectedIndices.length > 0) {
              // Pick a random unconnected ontology
              const randomIndex = Math.floor(Math.random() * unconnectedIndices.length);
              const targetIndex = unconnectedIndices[randomIndex];
              
              // Add a connection
              connections.push({
                source: i,
                target: targetIndex,
                strength: 0.3 // Lower strength for these additional connections
              });
              
              // Update counts and lists
              connectionCount++;
              unconnectedIndices.splice(randomIndex, 1);
            }
          }
        }
        
        // Render the connections first
        connections.forEach(connection => {
          const source = ontologies[connection.source];
          const target = ontologies[connection.target];
          
          const edge = document.createElement('div');
          edge.className = 'explorer-edge';
          
          // Calculate edge properties
          const length = Math.sqrt(Math.pow(target.x - source.x, 2) + Math.pow(target.y - source.y, 2));
          const angle = Math.atan2(target.y - source.y, target.x - source.x) * (180 / Math.PI);
          
          // Adjust opacity based on connection strength
          const opacity = 0.3 + (connection.strength * 0.7);
          
          // Apply styles
          edge.style.width = `${length}px`;
          edge.style.left = `${source.x}px`;
          edge.style.top = `${source.y}px`;
          edge.style.transform = `rotate(${angle}deg)`;
          edge.style.transformOrigin = '0 0';
          edge.style.opacity = opacity;
          
          canvas.appendChild(edge);
        });
        
        // Render the ontology nodes
        ontologies.forEach(ontology => {
          const node = document.createElement('div');
          node.className = 'explorer-node';
          node.innerHTML = `<span class="node-title">${ontology.title}</span>`;
          
          // Size node based on class count
          const baseSize = 40;
          const extraSize = Math.min(40, ontology.classes / 5);
          const size = baseSize + extraSize;
          
          node.style.width = `${size}px`;
          node.style.height = `${size}px`;
          node.style.left = `${ontology.x - (size/2)}px`;
          node.style.top = `${ontology.y - (size/2)}px`;
          
          // Add click event
          node.addEventListener('click', function() {
            window.location.href = `/ontology/detail?uri=${encodeURIComponent(ontology.uri)}&showLabels={{showLabels}}`;
          });
          
          // Add hover tooltip
          node.title = `${ontology.title}\nKlasser: ${ontology.classes}\nEgenskaper: ${ontology.properties}`;
          
          canvas.appendChild(node);
        });
        
        // Add search functionality
        const searchInput = document.getElementById('ontologySearch');
        if (searchInput) {
          searchInput.addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase();
            
            // Handle the search
            ontologies.forEach((ontology, index) => {
              const nodeElement = canvas.querySelector(`.explorer-node:nth-child(${ontologies.length + connections.length + index + 1})`);
              
              if (nodeElement) {
                if (ontology.title.toLowerCase().includes(searchTerm) || 
                    ontology.description.toLowerCase().includes(searchTerm) || 
                    searchTerm === '') {
                  nodeElement.style.opacity = '1';
                  nodeElement.style.transform = 'scale(1.1)';
                  nodeElement.style.zIndex = '10';
                } else {
                  nodeElement.style.opacity = '0.3';
                  nodeElement.style.transform = 'scale(0.8)';
                  nodeElement.style.zIndex = '1';
                }
              }
            });
          });
        }
      });
    </script>
    
    <style>
      .ontology-explorer {
        margin: 20px 0;
        background-color: #f7f9fc;
        border-radius: 8px;
        border: 1px solid #e0e6ef;
        overflow: hidden;
      }
      
      .explorer-search {
        padding: 15px;
        border-bottom: 1px solid #e0e6ef;
      }
      
      .explorer-search-input {
        width: 100%;
        padding: 10px;
        border: 1px solid #dbe1ea;
        border-radius: 4px;
        font-size: 14px;
      }
      
      .explorer-visualization {
        padding: 15px;
      }
      
      .explorer-canvas {
        position: relative;
        width: 100%;
        height: 400px;
        margin: 0 auto;
      }
      
      .explorer-node {
        position: absolute;
        background-color: #ffffff;
        border: 2px solid #0645ad;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
        overflow: hidden;
      }
      
      .explorer-node:hover {
        transform: scale(1.2) !important;
        box-shadow: 0 5px 10px rgba(0,0,0,0.2);
        z-index: 100 !important;
      }
      
      .explorer-node .node-title {
        font-size: 9px;
        text-align: center;
        color: #0645ad;
        font-weight: bold;
        max-width: 90%;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      
      .explorer-edge {
        position: absolute;
        height: 2px;
        background: linear-gradient(to right, #0645ad, #5698dc);
        border-radius: 2px;
        z-index: 0;
      }
    </style>
  </div>
</div>
<div class="ontology-grid">
  {{#each ontologies}}
    <div class="ontology-card">
      <div class="ontology-card-header">
        <h3>
          <a href="/ontology/detail?uri={{encodeURIComponent this.uri}}&showLabels={{../showLabels}}">
            {{this.title}}
          </a>
        </h3>
      </div>
      <div class="ontology-card-body">
        <p class="description">{{truncate this.description 150}}</p>
        
        <div class="ontology-stats">
          <span class="stat"><strong>Klasser:</strong> {{this.stats.classes}}</span>
          <span class="stat"><strong>Egenskaper:</strong> {{this.stats.properties}}</span>
          <span class="stat"><strong>Individer:</strong> {{this.stats.individuals}}</span>
        </div>
      </div>
    </div>
  {{/each}}

  {{#unless ontologies.length}}
    <div class="no-data-message">
      <p>❌ Inga ontologier hittades i databasen.</p>
    </div>
  {{/unless}}
</div>
<div class="display-mode">
<label for="displayToggle">Visa mänskligt läsbara etiketter:</label>
  <label class="switch">
    <input type="checkbox" id="displayToggle" {{#if showLabels}}checked{{/if}}>
    <span class="slider"></span>
  </label>
  <span class="display-mode-text">{{#if showLabels}}På{{else}}Av{{/if}}</span>
</div>
<div class="action-links">
  <a href="/search?showLabels={{showLabels}}" class="btn">Sök i databasen</a>
  <a href="/graphdb?showLabels={{showLabels}}" class="btn">Visa alla data</a>
  <a href="/query?showLabels={{showLabels}}" class="btn">Kör anpassad SPARQL-fråga</a>
</div>


<style>
  .ontology-card-body .description {
    margin-bottom: 15px;
    font-size: 14px;
    color: #333;
    max-height: 80px;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 4;
    -webkit-box-orient: vertical;
  }
  
  .ontology-card {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
  
  .ontology-card-body {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
  }
  
  .ontology-stats {
    margin-top: auto;
  }
</style>