<h1 class="page-title">{{title}}</h1>

<section class="intro-section">
  <p>
  <i>Välkommen till Ontology Browser, ett verktyg för att utforska och ladda ner ontologier från GraphDB-databasen.</i>
</p>
  
  <div class="info-box">
    <h3>Vad är en ontologi?</h3>
    <p>
     <i> En ontologi är en formell representation av kunskap inom ett visst område som definierar begrepp, relationer och 
      egenskaper. Ontologier används för att organisera information, möjliggöra semantisk interoperabilitet och 
      stödja dataintegration genom att tillhandahålla ett gemensamt vokabulär. </i>
    </p>
    <p>
     <i> I denna databas finns olika ontologier som kan laddas ner i flera format som RDF/XML, Turtle, N-Triples och JSON-LD.</i>
    </p>
  </div>
</section>
<div class="ontology-navigation">
  <h2>Ontologi Navigator</h2>
  <p>Utforska relaterade ontologier och hur de hänger ihop med varandra:</p>
  
  <div class="ontology-explorer">
    <div class="explorer-search">
      <input type="text" id="ontologySearch" placeholder="Sök ontologi..." class="explorer-search-input">
    </div>
    
    <div class="explorer-visualization">
      <div class="explorer-canvas" id="ontologyExplorerCanvas">
        <!-- Generated by JavaScript -->
      </div>
    </div>
    
    <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Get ontology data from the grid
        const ontologyCards = document.querySelectorAll('.ontology-card');
        const ontologies = [];
        
        ontologyCards.forEach((card, index) => {
          const titleElement = card.querySelector('.ontology-card-header h3 a');
          const descElement = card.querySelector('.ontology-card-body .description');
          const statsElements = card.querySelectorAll('.ontology-stats .stat');
          
          if (titleElement) {
            const uri = titleElement.getAttribute('href').split('uri=')[1].split('&')[0];
            
            ontologies.push({
              id: index,
              title: titleElement.textContent.trim(),
              uri: decodeURIComponent(uri),
              description: descElement ? descElement.textContent.trim() : '',
              classes: statsElements[0] ? parseInt(statsElements[0].textContent.split(':')[1].trim()) : 0,
              properties: statsElements[1] ? parseInt(statsElements[1].textContent.split(':')[1].trim()) : 0,
              x: 0,
              y: 0
            });
          }
        });
        
        // Only proceed if we have ontologies
        if (ontologies.length === 0) return;
        
        // Set up the explorer canvas
        const canvas = document.getElementById('ontologyExplorerCanvas');
        if (!canvas) return;
        
        const width = canvas.offsetWidth;
        const height = 400; // Fixed height
        canvas.style.height = height + 'px';
        
        // Position ontologies in a force-directed layout simulation
        // (Basic version for simplicity)
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) * 0.4;
        
        // Position in a circle first
        ontologies.forEach((ontology, index) => {
          const angle = (index / ontologies.length) * Math.PI * 2;
          ontology.x = centerX + radius * Math.cos(angle);
          ontology.y = centerY + radius * Math.sin(angle);
        });
        
        // Create connections between ontologies
        // We'll create connections based on some rules:
        // 1. Connect ontologies with similar titles
        // 2. Connect ontologies with similar class counts
        const connections = [];
        
        for (let i = 0; i < ontologies.length; i++) {
          for (let j = i + 1; j < ontologies.length; j++) {
            const ontologyA = ontologies[i];
            const ontologyB = ontologies[j];
            
            // Check title similarity (naive check for common words)
            const wordsA = ontologyA.title.toLowerCase().split(/\W+/);
            const wordsB = ontologyB.title.toLowerCase().split(/\W+/);
            const commonWords = wordsA.filter(word => wordsB.includes(word) && word.length > 3);
            
            // Check class count similarity
            const classDiff = Math.abs(ontologyA.classes - ontologyB.classes);
            const classRatio = Math.min(ontologyA.classes, ontologyB.classes) / Math.max(ontologyA.classes, ontologyB.classes) || 0;
            
            // Create connection if similar
            if (commonWords.length > 0 || classRatio > 0.7) {
              connections.push({
                source: ontologyA.id,
                target: ontologyB.id,
                strength: (commonWords.length * 0.2) + (classRatio * 0.8)
              });
            }
          }
        }
        
        // Always ensure minimum connectivity (connect to nearest neighbor)
        ontologies.forEach((ontology, i) => {
          if (!connections.some(c => c.source === i || c.target === i)) {
            // Find nearest neighbor by Euclidean distance
            let minDist = Infinity;
            let nearestIndex = -1;
            
            for (let j = 0; j < ontologies.length; j++) {
              if (i !== j) {
                const dist = Math.sqrt(
                  Math.pow(ontology.x - ontologies[j].x, 2) + 
                  Math.pow(ontology.y - ontologies[j].y, 2)
                );
                if (dist < minDist) {
                  minDist = dist;
                  nearestIndex = j;
                }
              }
            }
            
            if (nearestIndex >= 0) {
              connections.push({
                source: i,
                target: nearestIndex,
                strength: 0.5
              });
            }
          }
        });
        
        // Render the connections first
        connections.forEach(connection => {
          const source = ontologies[connection.source];
          const target = ontologies[connection.target];
          
          const edge = document.createElement('div');
          edge.className = 'explorer-edge';
          
          // Calculate edge properties
          const length = Math.sqrt(Math.pow(target.x - source.x, 2) + Math.pow(target.y - source.y, 2));
          const angle = Math.atan2(target.y - source.y, target.x - source.x) * (180 / Math.PI);
          
          // Adjust opacity based on connection strength
          const opacity = 0.3 + (connection.strength * 0.7);
          
          // Apply styles
          edge.style.width = `${length}px`;
          edge.style.left = `${source.x}px`;
          edge.style.top = `${source.y}px`;
          edge.style.transform = `rotate(${angle}deg)`;
          edge.style.transformOrigin = '0 0';
          edge.style.opacity = opacity;
          
          canvas.appendChild(edge);
        });
        
        // Render the ontology nodes
        ontologies.forEach(ontology => {
          const node = document.createElement('div');
          node.className = 'explorer-node';
          node.innerHTML = `<span class="node-title">${ontology.title}</span>`;
          
          // Size node based on class count
          const baseSize = 40;
          const extraSize = Math.min(40, ontology.classes / 5);
          const size = baseSize + extraSize;
          
          node.style.width = `${size}px`;
          node.style.height = `${size}px`;
          node.style.left = `${ontology.x - (size/2)}px`;
          node.style.top = `${ontology.y - (size/2)}px`;
          
          // Add click event
          node.addEventListener('click', function() {
            window.location.href = `/ontology/detail?uri=${encodeURIComponent(ontology.uri)}&showLabels={{showLabels}}`;
          });
          
          // Add hover tooltip
          node.title = `${ontology.title}\nKlasser: ${ontology.classes}\nEgenskaper: ${ontology.properties}`;
          
          canvas.appendChild(node);
        });
        
        // Add search functionality
        const searchInput = document.getElementById('ontologySearch');
        if (searchInput) {
          searchInput.addEventListener('input', function() {
            const searchTerm = this.value.toLowerCase();
            
            // Handle the search
            ontologies.forEach((ontology, index) => {
              const nodeElement = canvas.querySelector(`.explorer-node:nth-child(${ontologies.length + connections.length + index + 1})`);
              
              if (nodeElement) {
                if (ontology.title.toLowerCase().includes(searchTerm) || 
                    ontology.description.toLowerCase().includes(searchTerm) || 
                    searchTerm === '') {
                  nodeElement.style.opacity = '1';
                  nodeElement.style.transform = 'scale(1.1)';
                  nodeElement.style.zIndex = '10';
                } else {
                  nodeElement.style.opacity = '0.3';
                  nodeElement.style.transform = 'scale(0.8)';
                  nodeElement.style.zIndex = '1';
                }
              }
            });
          });
        }
      });
    </script>
    
    <style>
      .ontology-explorer {
        margin: 20px 0;
        background-color: #f7f9fc;
        border-radius: 8px;
        border: 1px solid #e0e6ef;
        overflow: hidden;
      }
      
      .explorer-search {
        padding: 15px;
        border-bottom: 1px solid #e0e6ef;
      }
      
      .explorer-search-input {
        width: 100%;
        padding: 10px;
        border: 1px solid #dbe1ea;
        border-radius: 4px;
        font-size: 14px;
      }
      
      .explorer-visualization {
        padding: 15px;
      }
      
      .explorer-canvas {
        position: relative;
        width: 100%;
        height: 400px;
        margin: 0 auto;
      }
      
      .explorer-node {
        position: absolute;
        background-color: #ffffff;
        border: 2px solid #0645ad;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
        overflow: hidden;
      }
      
      .explorer-node:hover {
        transform: scale(1.2) !important;
        box-shadow: 0 5px 10px rgba(0,0,0,0.2);
        z-index: 100 !important;
      }
      
      .explorer-node .node-title {
        font-size: 9px;
        text-align: center;
        color: #0645ad;
        font-weight: bold;
        max-width: 90%;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      
      .explorer-edge {
        position: absolute;
        height: 2px;
        background: linear-gradient(to right, #0645ad, #5698dc);
        border-radius: 2px;
        z-index: 0;
      }
    </style>
  </div>
</div>
<div class="ontology-grid">
  {{#each ontologies}}
    <div class="ontology-card">
      <div class="ontology-card-header">
        <h3>
          <a href="/ontology/detail?uri={{encodeURIComponent this.uri}}&showLabels={{../showLabels}}">
            {{this.title}}
          </a>
        </h3>
      </div>
      <div class="ontology-card-body">
        <p class="description">{{truncate this.description 150}}</p>
        
        <div class="ontology-stats">
          <span class="stat"><strong>Klasser:</strong> {{this.stats.classes}}</span>
          <span class="stat"><strong>Egenskaper:</strong> {{this.stats.properties}}</span>
          <span class="stat"><strong>Individer:</strong> {{this.stats.individuals}}</span>
        </div>
      </div>
    </div>
  {{/each}}

  {{#unless ontologies.length}}
    <div class="no-data-message">
      <p>❌ Inga ontologier hittades i databasen.</p>
    </div>
  {{/unless}}
</div>
<div class="display-mode">
<label for="displayToggle">Visa mänskligt läsbara etiketter:</label>
  <label class="switch">
    <input type="checkbox" id="displayToggle" {{#if showLabels}}checked{{/if}}>
    <span class="slider"></span>
  </label>
  <span class="display-mode-text">{{#if showLabels}}På{{else}}Av{{/if}}</span>
</div>
<div class="action-links">
  <a href="/search?showLabels={{showLabels}}" class="btn">Sök i databasen</a>
  <a href="/graphdb?showLabels={{showLabels}}" class="btn">Visa alla data</a>
  <a href="/query?showLabels={{showLabels}}" class="btn">Kör anpassad SPARQL-fråga</a>
</div>


<style>
  .ontology-card-body .description {
    margin-bottom: 15px;
    font-size: 14px;
    color: #333;
    max-height: 80px;
    overflow: hidden;
    display: -webkit-box;
    -webkit-line-clamp: 4;
    -webkit-box-orient: vertical;
  }
  
  .ontology-card {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
  
  .ontology-card-body {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
  }
  
  .ontology-stats {
    margin-top: auto;
  }
</style>